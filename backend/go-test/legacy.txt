package main

import (
	"bufio"
	"fmt"
	"log"
	"mime/multipart"
	"os"
	"regexp"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	"github.com/jung-kurt/gofpdf"
)

// Record structure to hold the fields of each record
type Record struct {
	RecordID      string
	Reference     string
	Category      string
	ID            string
	TemplateType  string
	RequestDate   string
	OwnerName     string
	Address       string
	Telephone     string
	ContractNumber string
	AgentName     string
	ProductName   string
	IssueDate     string
	Postcode      string
}

// Helper function to parse the uploaded TXT file
func parseFile(file multipart.File) ([]Record, error) {
	var records []Record

	// Regular expression to split by spaces but keep quoted values as one field
	re := regexp.MustCompile(`"([^"]*)"|(\S+)`)

	scanner := bufio.NewScanner(file)
	isHeader := true
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		// Skip the first line (header)
		if isHeader {
			isHeader = false
			continue
		}

		// Find matches in the line
		matches := re.FindAllString(line, -1)

		// Ensure the correct number of fields are extracted
		if len(matches) < 14 {
			return nil, fmt.Errorf("invalid format: expected 14 columns, got %d in line: %s", len(matches), line)
		}

		// Populate the Record struct
		record := Record{
			RecordID:       strings.Trim(matches[0], `"`),
			Reference:      strings.Trim(matches[1], `"`),
			Category:       strings.Trim(matches[2], `"`),
			ID:             strings.Trim(matches[3], `"`),
			TemplateType:   strings.Trim(matches[4], `"`),
			RequestDate:    strings.Trim(matches[5], `"`),
			OwnerName:      strings.Trim(matches[6], `"`),
			Address:        strings.Trim(matches[7], `"`),
			Telephone:      strings.Trim(matches[8], `"`),
			ContractNumber: strings.Trim(matches[9], `"`),
			AgentName:      strings.Trim(matches[10], `"`),
			ProductName:    strings.Trim(matches[11], `"`),
			IssueDate:      strings.Trim(matches[12], `"`),
			Postcode:       strings.Trim(matches[13], `"`),
		}

		records = append(records, record)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return records, nil
}


// Function to generate PDF from record data
func generatePDF(record Record, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")

	// Add a page
	pdf.AddPage()

	// Set the font for the header
	pdf.SetFont("Arial", "B", 16)
	pdf.SetTextColor(0, 51, 102) // Dark Blue color for header
	pdf.Cell(200, 10, fmt.Sprintf("Record Details - %s", record.Reference))
	pdf.Ln(12) // Line break with height of 12mm

	// Set the font for the body content
	pdf.SetFont("Arial", "", 12)
	pdf.SetTextColor(0, 0, 0) // Black color for body text

	// Add a table with labels and values
	headers := []string{"Field", "Details"}
	widths := []float64{60, 130}

	// Draw a header row with a border
	pdf.SetFillColor(0, 51, 102) // Dark Blue for header background
	pdf.SetTextColor(255, 255, 255) // White text color
	for i, header := range headers {
		pdf.CellFormat(widths[i], 8, header, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(8) // Line break with height of 8mm

	// Reset text color to black for data rows
	pdf.SetTextColor(0, 0, 0)
	data := [][]string{
		{"Record ID", record.RecordID},
		{"Reference", record.Reference},
		{"Category", record.Category},
		{"ID", record.ID},
		{"Template Type", record.TemplateType},
		{"Request Date", record.RequestDate},
		{"Owner Name", record.OwnerName},
		{"Address", record.Address},
		{"Telephone", record.Telephone},
		{"Contract Number", record.ContractNumber},
		{"Agent Name", record.AgentName},
		{"Product Name", record.ProductName},
		{"Issue Date", record.IssueDate},
		{"Postcode", record.Postcode},
	}

	// Add rows for each data entry
	for _, row := range data {
		for i, field := range row {
			pdf.CellFormat(widths[i], 8, field, "1", 0, "L", false, 0, "")
		}
		pdf.Ln(8) // Line break with height of 8mm after each row
	}

	// Add some space after the table
	pdf.Ln(10) // Line break with height of 10mm

	// Add a footer (optional)
	pdf.SetFont("Arial", "I", 8)
	pdf.SetTextColor(150, 150, 150) // Light gray color
	pdf.Cell(200, 10, "Generated by Your System - All rights reserved.")
	pdf.Ln(5) // Line break with height of 5mm for footer

	// Output the file to the specified filename
	err := pdf.OutputFileAndClose(filename)
	if err != nil {
		return fmt.Errorf("error generating PDF: %v", err)
	}
	return nil
}



func main() {
	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	// Get the storage path from environment variable
	storagePath := os.Getenv("PDF_STORAGE_PATH")
	if storagePath == "" {
		log.Fatal("PDF_STORAGE_PATH is not set in .env file")
	}

	// Initialize Gin router
	router := gin.Default()

	// Route for file upload and PDF generation
	router.POST("/upload", func(c *gin.Context) {
		// Get the uploaded file from the form data
		file, _, err := c.Request.FormFile("file")
		if err != nil {
			c.JSON(400, gin.H{"error": "Failed to get file"})
			return
		}
		defer file.Close()

		// Parse the file
		records, err := parseFile(file)
		if err != nil {
			c.JSON(400, gin.H{"error": fmt.Sprintf("Failed to parse file: %v", err)})
			return
		}

		// Create the storage directory if it doesn't exist
		if _, err := os.Stat(storagePath); os.IsNotExist(err) {
			err := os.MkdirAll(storagePath, os.ModePerm)
			if err != nil {
				c.JSON(500, gin.H{"error": "Failed to create storage directory"})
				return
			}
		}

		// Generate PDF for each record
		for i, record := range records {
			// Create a unique filename for each record's PDF
			filename := fmt.Sprintf("%s/record_%d.pdf", storagePath, i+1)

			// Generate the PDF
			err := generatePDF(record, filename)
			if err != nil {
				c.JSON(500, gin.H{"error": fmt.Sprintf("Failed to generate PDF for record %d: %v", i+1, err)})
				return
			}

			// Optionally, send the generated file as a response (or a success message)
			// Here, we're just printing the file path for now
			c.JSON(200, gin.H{"message": fmt.Sprintf("PDF for record %d generated successfully: %s", i+1, filename)})
		}
	})

	// Start the server
	log.Fatal(router.Run(":8080"))
}
